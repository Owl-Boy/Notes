---
tags:
  - Note
  - Incomplete
---
202310291410

Tags : [[Programming Languages]]
# Optimisations for Expressions containing $\text{FAIL}$ and $\triangleright$
---
>[!warning] Redundancies
>It is often the case that all occurrences of $\text{FAIL}$, and its companion $\triangleright$ can be eliminated. Most of the these optimisations depend on reasoning that $\text{FAIL}$ can never be returned by an expression $E$. In the above cases, the corresponding occurrences of $\triangleright$ can  also be removed.

If $\text{FAIL}$ is returned by an expression $E$ then one of the following is necessary
1. $\text{FAIL}$ is mentioned explicitly in  $E$
2. $E$ contains a pattern-matching lambda abstraction whose application may fail
3. $\text{FAIL}$ is the value of one of the free variables of $E$.

If the [[Match Function for Enriched Lambda Calculus|pattern matching compiler]] is applied throughout then there will be no pattern matching lambda expressions hence **2.** will never happen.
And presumably since the programmer cannot write $\text{FAIL}$, **3.** will never happen.

Hence we focus on all the places where $\text{FAIL}$ can be introduced by the compiler. There are only 2 such places
- In the translation of conditional equations
- In the variant of pattern-matching compiler
>[!todo] 
>Link Pattern Matching Compiler from the next section of the book

---
## Transformation rules for $\triangleright$ and $\text{FAIL}$

- We can eliminate $\triangleright$ and $\text{FAIL}$ if the side cannot produce $\text{FAIL}$
$$
E_{1} \triangleright E_{2} \equiv E_{1}
$$
  If $E_1$ cannot return $\text{FAIL}$
- We can also eliminate $\triangleright$ if $FAIL$ is definitely produced on one side
$$
E \triangleright \text{FAIL} \equiv E  
\quad\quad \text{and} \quad\quad 
\text{FAIL} \triangleright E \equiv E
$$

The second point comes from the fact that $\text{FAIL}$ is the identity element for the operator $\triangleright$.

Using the above rules and the [[Patterns#Semantics for the $ triangleright$ operator|Semantics for the operator]] we also get the following rule
$$
(\text{IF}\ E_{1}\ E_{2}\ E_{3}) \triangleright E\quad \equiv\quad \text{IF}\ E_{1}\ E_{2}\ (E_{3}\triangleright E)
$$
If $E_1$ and $E_2$ cannot return fail.

---
## Eliminating $\triangleright$ and $\text{FAIL}$ from conditional equations
After the pattern matching compilation is done, then [[Empty Rule for Match Function]] gives an expression of the following form.
$$
E_{1} \triangleright E_{2} \triangleright \dots E_{m} \triangleright E
$$
Now the $E_i$ might be a set of conditional equations with guards. If there is no `otherwise` case in the end, then the expression must have translated to
```
IF G1 A1 (IF ... (IF Gg Ag FAIL) ... )
```
where `g` is the number of alternatives of the guards.

If there is an `otherwise` case there is no $\text{FAIL}$ produced and we get an expression of the form
```
IF G1 A1 (IF ... (IF G(g-1) A(g-1) Ag) ... )
```

If the right hand side of one of the $E_i$ is of this form, then we can use the third rule followed by the second to give

$$
\begin{matrix}
(\text{IF}\ G_{1}\ A_{1} (\text{IF}\ \dots (\text{IF} \ G_{g}\ A_{g}\ \text{FAIL})\ \dots ))\triangleright E \\
\equiv \\

\text{IF}\ G_{1}\ A_{1} (\text{IF}\ \dots (\text{IF} \ G_{g}\ A_{g}\ E)\ \dots ) \\
\end{matrix}
$$

Application of the three rules eliminates all occurrences of $\text{FAIL}$ in the expression generated by the [[Empty Rule for Match Function|empty rule]].

---
# References
- [[Optimisations for Overlapping Patterns]]
- [[Match Function for Enriched Lambda Calculus]]